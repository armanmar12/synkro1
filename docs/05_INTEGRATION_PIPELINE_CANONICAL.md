# Synkro: Канонический пайплайн интеграций (amoCRM -> Radist -> Supabase -> AI -> Telegram)

Обновлено: 2026-02-20
Статус: рабочий канон по интеграционному контуру

## 1. Цель документа
Зафиксировать окончательный подход, который был найден после нескольких попыток, чтобы не терять логику:
- как берем данные из amoCRM;
- как правильно ходим в Radist;
- как склеиваем данные;
- как сохраняем в Supabase без дублей;
- как формируем AI-запрос и сохраняем результат;
- как делаем Telegram-рассылку;
- как держим tenant-изоляцию.

## 2. Главные инварианты
1. amoCRM только read-only.
2. Базовая сущность в хранилище: сделка (`deal`).
3. Одна строка в `deals` = одна сделка.
4. Никаких дублей по сделке: upsert по ключу (`tenant_id`, `deal_id`).
5. Весь диалог сделки хранится внутри этой же строки:
   - `dialog_raw` (jsonb)
   - `dialog_norm` (text)
6. Данные разных tenant не смешиваются (`tenant_id` обязателен везде).
7. После AI-анализа отчет сохраняется в `reports`.
8. Follow-up уточнения доступны в вебе и Telegram (по `@`-упоминанию бота).

## 2.1 Режимы runtime-пайплайна
- `amocrm_radist`: полный контур amoCRM + Radist + Supabase + AI + Telegram.
- `radist_only`: загрузка диалогов из Radist, фильтрация по рабочим суткам tenant, запись в Supabase, затем AI + Telegram.
- `amocrm_only`: отчет только по данным amoCRM (без анализа диалогов Radist).
- Режим задается tenant-настройкой `TenantRuntimeConfig.mode`.

## 3. Таблицы Supabase (фактическая схема)
Источник: `supabase/migrations/001_init.sql`

## 3.1 `public.deals`
- PK: (`tenant_id`, `deal_id`)
- Ключевые поля:
  - `deal_name`, `status_id`, `status`, `responsible`, `phone`, `chat_id`
  - `first_message_at`, `last_message_at`, `messages_count`
  - `dialog_raw` (сырой массив сообщений Radist)
  - `dialog_norm` (нормализованный текстовый диалог)

## 3.2 `public.reports`
- Поля:
  - `tenant_id`, `report_date`, `type`, `text`, `comment`, `created_at`
  - `source_report_id` (nullable, уникальный id отчета из приложения; позволяет строго различать несколько отчетов в один день)

## 4. Порядок пайплайна
## Шаг 1. amoCRM: получаем сделки и связи
Используем:
- `/api/v4/leads`
- `/api/v4/leads/{id}/links`
- `/api/v4/contacts`

Что берем:
- `lead_id`/`deal_id`, `lead_name`, `status_id`, `responsible`
- контактные телефоны для матчинга с Radist

Результат шага:
- список сделок за окно времени;
- у каждой сделки есть нормализованный телефон.

## Шаг 2. Первичный upsert сделок в Supabase
Записываем/обновляем строку сделки в `deals`:
- `tenant_id`, `deal_id`, метаданные сделки и контакта;
- диалоговые поля пока пустые или с текущим состоянием.

Цель:
- убедиться, что база сделок уже есть и целостна до обращения к Radist.

## Шаг 3. Radist: правильный способ получения диалогов
Подтвержденный подход (по рабочим пробам в `temp/research/test api`):
1. Получить доступные источники чатов:
   - `/companies/{company_id}/messaging/chats/sources/`
2. Взять контакты с чатами:
   - `/companies/{company_id}/messaging/chats/with_contacts/`
3. Отфильтровать нужные каналы (`whatsapp`, `waba`) и окно времени.
4. Для каждого chat получить сообщения:
   - `/companies/{company_id}/messaging/messages/?chat_id=...`
   - пагинация через `until`, защита от 429 (retry/backoff).

Результат шага:
- набор сообщений чата, привязанный к телефону/сделке.

## Шаг 4. Склейка amoCRM + Radist
Ключ склейки:
- телефон контакта (нормализованный формат, digits-only).

Что обновляем в строке сделки:
- `chat_id`
- `messages_count`
- `first_message_at`, `last_message_at`
- `dialog_raw` = полный массив сообщений
- `dialog_norm` = единый человекочитаемый текст диалога (хронология + роли)

Критично:
- не создаем новые строки под отдельные сообщения;
- не делим одну сделку на несколько строк.

## Шаг 5. Upsert без дублей
Текущая рабочая запись в Supabase делается через:
- `on_conflict=tenant_id,deal_id`

Это уже зафиксировано в `scripts/push_deals_to_supabase.ps1`.

## Шаг 6. AI-анализ
Формируем пакет:
- prompt клиента;
- данные диалога из Supabase (обычно `dialog_norm` + нужный контекст).

Отправляем в AI API и получаем ответ.

Сохраняем:
- итог отчета в `reports` (tenant-изолированно);
- при необходимости служебные метаданные в центральной БД сервиса.

## Шаг 7. Telegram-рассылка
После успешного AI шага:
- отправляем краткий отчет в Telegram (по настройкам tenant).

## Шаг 8. Follow-up (веб + Telegram)
После выдачи отчета:
- пользователь может задавать уточняющие вопросы в карточке отчета в вебе;
- в Telegram бот отвечает только на сообщения с `@`-упоминанием (остальные сообщения игнорируются);
- каждый вопрос/ответ сохраняется в `ReportMessage`.

## 5. Tenant-изоляция и админ-настройки
Изоляция достигается через:
- отдельные интеграционные настройки на tenant (`IntegrationConfig`);
- обязательный `tenant_id` в данных;
- отдельные ключи/токены и отдельный Supabase-проект на клиента (по модели).

Поток настройки через админку:
1. Заполняем ключи интеграций по очереди.
2. Запускаем проверку каждого шага.
3. Делаем тестовую загрузку 3 диалогов.
4. Смотрим индикаторы статуса, что шаг рабочий.

## 6. Где это в коде/репозитории
- Схема данных Supabase: `supabase/migrations/001_init.sql`, `supabase/migrations/002_reports_source_report_id.sql`
- Текущий upsert скрипт: `scripts/push_deals_to_supabase.ps1`
- Исследовательские пробы Radist/склейки: `temp/research/test api/`
- Исторические решения и контекст: `temp/legacy_docs/SYNKRO_BUILD_PLAN_RU.md`

## 7. Что считать “истиной” при конфликте
Если старые черновики противоречат:
1. Этот документ.
2. `supabase/migrations/001_init.sql`, затем `supabase/migrations/002_reports_source_report_id.sql`.
3. Реальное поведение production-кода.
